Комитет TC39 недавно одобрил что войдёт в стандарт [ECMAScript 2020 (широко известную как ES2020),](https://github.com/tc39/ecma262/releases/tag/es2020 "ECMAScript 2020 (широко известную как ES2020),") которая содержит завершенный набор улучшений, входящий в язык JavaScript. Стандарт ES2020 должен быть рассмотрен и утвержден Генеральной ассамблеей ECMA в июне этого года. Большинство новых улучшений уже реализованы в браузерах и могут использоваться с помощью транспайлера [Babel](https://babeljs.io/).

#### Спецификация ES2020 будет содержать:
- `matchAll` - метод `Strings`, который создаёт итератор для всех объектов соответствия, сгенерированных глобальным регулярным выражением;
- `import ()` - синтаксис для асинхронного импорта модулей с динамическим спецификатором;
- `BigInt` - для работы с произвольными целыми числами больших, чем 25 в 53 - 1  ; 
- `Promise.allSettled` - новый комбинатор Promise, который не замыкается;
- `globalThis` - универсальный способ доступа к глобальному значению this; 
- выделенный экспорт `* as ns  from 'module'` для использования внутри модулей;
- повышена стандартизация `for-in` порядка перечисления;
- `import.meta` - объект, заполненный хостом, доступный в модулях, который может содержать контекстную информацию о модуле; 
- и две новые функции синтаксиса для улучшения работы с «нулевыми» значениями (`null` или `undefined`): 
  [nullish coalescing](http://novavovikov.ru/chto-takoe-nullish-coalescing/) - оператор выбора значений; 
  [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) - позволяет считывать значение свойства, расположенного глубоко в цепочке связанных объектов, без необходимости явно проверять правильность каждой ссылки в цепочке.
  

#### [Динамический импорт](https://exploringjs.com/impatient-js/ch_modules.html#loading-modules-dynamically-via-import)
Может использоваться для динамической загрузки модулей, созданных на этапе разделения кода в отдельные бандлы. Динамический импорт поддерживается [большинством браузеров](https://exploringjs.com/impatient-js/ch_modules.html#loading-modules-dynamically-via-import), за исключением IE11. С помощью `import ()` разработчики могут импортировать динамически созданный модуль (`moduleSpecifier = dir + 'my-math.mjs'`) асинхронно (вернётся Promise). Можно использовать по условию в любом месте кода:

<script async="" src="//jsfiddle.net/NovaVovikov/nkxzj9t8/embed/js/dark/"></script>

#### [import.meta](https://github.com/tc39/proposal-import-meta)
Это объект, который содержит специфичные для хоста метаданные о текущем модуле. На сегодняшний день наиболее интересным свойством является `url`, то есть строка с URL-адресом текущего файла модуля. Наличие этого URL позволяет разработчикам импортировать связанные модули или условно выполнять операции в зависимости от текущего модуля. Предложение предлагает следующий пример, который выбирает файл `hamster.jpg` относительно текущего модуля:

<script async="" src="//jsfiddle.net/NovaVovikov/12e7b3tf/embed/js/dark/"></script>

> Когда этот модуль загружен, независимо от его местоположения, он загрузит одноуровневый файл hamsters.jpg и отобразит изображение. Размер изображения можно настроить с помощью элемента script, который используется для его импорта, например: `<script type = "module" src = "path/to/hamster-displayer.mjs" data-size = "500"> </ script>`


#### [globalThis](https://github.com/tc39/proposal-global)
Ключевое слово `globalThis` позволяет разработчикам писать код ECMAScript, который обращается к глобальному объекту, избавляя от необходимости использовать `window`, `self`, `global` соответственно в браузере, воркере, Node.js и работая с [другими средами](https://github.com/tc39/proposal-global#rationale).
